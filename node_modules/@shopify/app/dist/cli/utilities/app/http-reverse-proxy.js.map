{"version":3,"file":"http-reverse-proxy.js","sourceRoot":"","sources":["../../../../src/cli/utilities/app/http-reverse-proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import {renderDev} from '../../services/dev/output.js'\nimport {RenderConcurrentOptions} from '@shopify/cli-kit/node/ui'\nimport {getAvailableTCPPort} from '@shopify/cli-kit/node/tcp'\nimport {AbortController, AbortSignal} from '@shopify/cli-kit/node/abort'\nimport {OutputProcess, outputDebug, outputContent, outputToken, outputWarn} from '@shopify/cli-kit/node/output'\nimport {Writable} from 'stream'\nimport * as http from 'http'\n\nexport interface ReverseHTTPProxyTarget {\n  /** The prefix to include in the logs\n   *   [vite] Output coming from Vite\n   */\n  logPrefix: string\n\n  /**\n   * The port to use for the target HTTP server. When undefined, a random port is automatically assigned.\n   */\n  customPort?: number\n\n  /**\n   * The HTTP path prefix used to match against request and determine if the traffic should be\n   * forwarded to this target\n   */\n  pathPrefix?: string\n\n  /**\n   * The configuration for a separate HMR server for this target.\n   */\n  hmrServer?: {\n    port: number\n    httpPaths: string[]\n  }\n\n  /**\n   * A callback to invoke the process. stdout and stderr should be used\n   * to send standard output and error data that gets formatted with the\n   * right prefix.\n   */\n  action: (stdout: Writable, stderr: Writable, signal: AbortSignal, port: number) => Promise<void> | void\n}\n\ninterface Options {\n  previewUrl: string\n  portNumber: number\n  proxyTargets: ReverseHTTPProxyTarget[]\n  additionalProcesses: OutputProcess[]\n  app: {\n    canEnablePreviewMode: boolean\n    developmentStorePreviewEnabled?: boolean\n    apiKey: string\n    token: string\n  }\n  abortController?: AbortController\n}\n\n/**\n * A convenient function that runs an HTTP server and does path-based traffic forwarding to sub-processes that run\n * an HTTP server. The method assigns a random port to each of the processes.\n * @param tunnelUrl - The URL of the tunnel.\n * @param portNumber - The port to use for the proxy HTTP server. When undefined, a random port is automatically assigned.\n * @param proxyTargets - List of target processes to forward traffic to.\n * @param additionalProcesses - Additional processes to run. The proxy won't forward traffic to these processes.\n * @returns A promise that resolves with an interface to get the port of the proxy and stop it.\n */\nexport async function runConcurrentHTTPProcessesAndPathForwardTraffic({\n  previewUrl,\n  portNumber,\n  proxyTargets,\n  additionalProcesses,\n  app,\n  abortController,\n}: Options): Promise<void> {\n  // Lazy-importing it because it's CJS and we don't want it\n  // to block the loading of the ESM module graph.\n  const {default: httpProxy} = await import('http-proxy')\n\n  const rules: {[key: string]: string} = {}\n\n  const processes = await Promise.all(\n    proxyTargets.map(async (target): Promise<OutputProcess> => {\n      const targetPort = target.customPort || (await getAvailableTCPPort())\n      rules[target.pathPrefix ?? 'default'] = `http://localhost:${targetPort}`\n      const hmrServer = target.hmrServer\n      if (hmrServer) {\n        rules.websocket = `http://localhost:${hmrServer.port}`\n        hmrServer.httpPaths.forEach((path) => (rules[path] = `http://localhost:${hmrServer.port}`))\n      }\n\n      return {\n        prefix: target.logPrefix,\n        action: async (stdout, stderr, signal) => {\n          await target.action(stdout, stderr, signal, targetPort)\n        },\n      }\n    }),\n  )\n\n  outputDebug(outputContent`\nStarting reverse HTTP proxy on port ${outputToken.raw(portNumber.toString())}\nRouting traffic rules:\n${outputToken.json(JSON.stringify(rules))}\n`)\n\n  const proxy = httpProxy.createProxy()\n  const server = http.createServer(function (req, res) {\n    const target = match(rules, req)\n    if (target) {\n      return proxy.web(req, res, {target}, (err) => {\n        outputWarn(`Error forwarding web request: ${err}`)\n      })\n    }\n\n    outputDebug(`\nReverse HTTP proxy error - Invalid path: ${req.url}\nThese are the allowed paths:\n${outputToken.json(JSON.stringify(rules))}\n`)\n\n    res.statusCode = 500\n    res.end(`Invalid path ${req.url}`)\n  })\n\n  // Capture websocket requests and forward them to the proxy\n  server.on('upgrade', function (req, socket, head) {\n    const target = match(rules, req, true)\n    if (target) {\n      return proxy.ws(req, socket, head, {target}, (err) => {\n        outputWarn(`Error forwarding websocket request: ${err}`)\n      })\n    }\n    socket.destroy()\n  })\n\n  const controller = abortController ?? new AbortController()\n\n  controller.signal.addEventListener('abort', () => {\n    outputDebug('Closing reverse HTTP proxy')\n    server.close()\n  })\n\n  const renderConcurrentOptions: RenderConcurrentOptions = {\n    processes: [...processes, ...additionalProcesses],\n    abortController: controller,\n  }\n\n  await Promise.all([renderDev(renderConcurrentOptions, previewUrl, app), server.listen(portNumber)])\n}\n\nfunction match(rules: {[key: string]: string}, req: http.IncomingMessage, websocket = false) {\n  const path: string = req.url ?? '/'\n\n  for (const pathPrefix in rules) {\n    if (path.startsWith(pathPrefix)) return rules[pathPrefix]\n  }\n\n  if (websocket && rules.websocket) return rules.websocket\n\n  return rules.default\n}\n"]}